import numpy as np
import pretty_midi
import glob

#This file reads in the midi files in a directory, converts them to a string representation
#when in a string representation it then gathers some statistics about the structure of the song

def get_piano_roll(midifile):
	midi_pretty_format = pretty_midi.PrettyMIDI(midifile)
	piano_midi = midi_pretty_format.instruments[0] # Get the piano channels
	piano_roll = piano_midi.get_piano_roll(fs=20)
	return piano_roll


def encode(arr):
    timeinc=0
    outString=""
    for time in arr:
        notesinc = -1
        #print(time)
        if np.all(time==0):
            outString=outString+"#"
        for vel in arr[timeinc]:
            notesinc=notesinc+1
            if vel != 0:
                noteRep=str(notesinc) + " "
                #print(noteRep)
                outString=outString+noteRep
        outString=outString+"\n"
        timeinc = timeinc+1
    return outString


def getSilences(test):
    test=test[:-1]
    output=test.split("\n")
    res = len(output)
    maxcounter=0
    counter=0
    silenceCount=0
    for x in output:
        if x == "#":
            counter=counter+1
            silenceCount+=1
        if x != "#":
            counter=0
        if counter>maxcounter:
            maxcounter=counter
    return maxcounter,silenceCount


def getPercentSilence(gen,silences):
    test = gen
    test = test[:-1]
    output = test.split("\n")
    res = len(output)
    percent=silences/res
    return percent


def getStatsNotes(test):
    test=test[:-1]
    notes=[]
    output = test.split("\n")
    maxPerSamp=0
    silenceSamp=0
    notesPlayed=0
    maxNotes=0
    maxVal=0
    minVal=127
    for x in output:
        samp=x.split(" ")
        samp=samp[:-1]
        while "0" in samp:
            samp.remove("0")
        if len(samp)==0:
            silenceSamp+=1
        notesPlayed=notesPlayed+len(samp)
        if len(samp)>0:
            minimum=min(samp)
            maximum=max(samp)
            if int(minimum)<minVal:
                minVal=int(minimum)
            if int(maximum)>maxVal:
                maxVal=int(maximum)
        if len(samp)>maxNotes:
            maxNotes=len(samp)
    rangeNotes=maxVal-minVal
    avgNotes = notesPlayed / len(output)
    adjNotes=notesPlayed /(len(output)-silenceSamp)
    return rangeNotes, maxVal, minVal,maxNotes,avgNotes,adjNotes


files=glob.glob(r"*.midi")
print(files)

for f in files:
    print(f)
    pr = get_piano_roll(f)
    arr = pr.T
    outString= encode(arr)
    maxsilences, silences = getSilences(outString)
    noteRange, maxVal, minVal, maxNotes, avgNotes, adjAvg =getStatsNotes(outString)
    percentSilence= getPercentSilence(outString,silences)
    print("longest silence is ",maxsilences,"samples long")
    print("silence covers:",round(percentSilence,4),"%")
    print("notes span range:",noteRange)
    print("max note value:",maxVal)
    print("min note value:",minVal)
    print("average number of notes per sample:",round(avgNotes,4))
    print("average number of notes per sample (adjusted to remove silence samples):",round(adjAvg,4))
    print("max number of notes played in a sample:",maxNotes)
    print("\n")

#NOTE some minor discrepencies vs reading in from generated file directly
#However this does provide a uniform check to use for songs generated by both encoding schemes
#Can also be used to evaluate training file
#uses split encoding to get the text representation for ease of development
